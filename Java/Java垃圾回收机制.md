## 垃圾回收机制

> JVM使用了可达性算法，从GC Roots开始计算，即使对象之间互相引用，但是没有与根节点连接，都判定为**垃圾**

JVM堆内存分为**年轻代**和**年老代**

- 年轻代：存放周期较短的变量
- 年老代：存放生命周期较长的变量

默认的比例是1:2，其中年轻代中包含1个 **Eden区** 和2个 **Survivor区** 默认比例是8:1:1，Eden存放新生的对象，Survivor存放每次回收后的存活对象

垃圾回收算法分为以下几种：

- **标记清除算法**：简单高效，缺点是清楚后内存容易碎片化，可能会分配整块内存时因为空间不够而触发GC

- **复制算法**：简单高效，空间换时间，不容易内存碎片化，每次将存活的对象复制到等分的另一块内存中，然后清除原来的内存空间

- **标记整理算法**：标记阶段原理和标记清除算法一样，只不过是将存活对象整理到一端，然后清理垃圾，保证空余内存的连续性

- **分代回收算法**：综合复制算法和标记整理算法，
复制算法适合存活对象较少，垃圾多的场景，年轻代
标记清除算法适合存活对象较多，垃圾少的场景，年老代

当生成对象时，需要申请内存空间，先在 **Eden区** 申请空间，如果空间不足，触发一次 **GC**，将 **Eden区** 中的存活对象复制到**Survior0**，然后清空 **Eden区** ，当**survior0**存满时，触发一次 **GC** ，将 **Eden区** 和**survior0**的存活对象复制**survior1**，然后清空**Eden区** 和**survior0**，然后将**survior0**和**survior1**交换，维持**survior1** 为空。如果**survior1**的空间无法存放 **Eden区** 和**survior0**的存活对象 或者 对象在**survior**中存活了指定的**GC**次数（默认是 **15** 次数）则会被移动到 **年老代** ，当**年老代** 的空间不足是会触发一次**Full GC** ，对 **新生代** 和 **年老代** 都进行回收

- 年轻代中的GC，发生非常频繁，甚至 **Eden区** 还未满时也会触发
- 年老代中的GC，效率低下


## 垃圾回收器

[垃圾回收器](http://blog.csdn.net/kimylrong/article/details/18265807)