## Java锁

Lock机制弥补了synchronized获取锁时无法中断的缺陷，例如死锁

### 分类

#### 悲观锁、乐观锁

##### 悲观锁

悲观的认为对同一个数据的并发操作，一定会发生修改，必须要加锁，不然会有问题

悲观锁适合**写**操作密集的场景，在Java中的场景就是加锁操作

####  乐观锁

乐观的认为对同一个数据的鬓发操作，是不会发生修改的，在最后更新数据的时候，会采用尝试更新的方式去同步

乐观锁适合**读**操作密集的场景，无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新

#### ReentrantLock

可重入锁，排它锁

- lock：死循环获取锁，获取不到则一直阻塞，直到获取到锁

- tryLock：获取一次锁，获取到就返回true，程序继续往下运行，可以设置获取锁的超时时间

- lockInterruptibly：同lock方法，但是响应中断
























