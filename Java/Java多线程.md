## Java多线程

线程同步问题是由线程的私有内存和堆内存之间不同步导致的，即可见性，进程之间的内存空间不同，线程共享所属进程的堆内存

### 一、关键字

#### volatile

用来修饰变量

- 修饰的变量对所有线程都是来自主内存最新的，可见性
- 防止编译器编译后的优化操作(指令重排)

不能保证原子性操作，例如 **i++** ，在多线程复杂环境下的单例模式下需加该关键字，因为一个类实例化的过程是分步的，先分配内存空间，接着初始化类，最后指向地址

#### synchronized

修饰方法或者代码块，在方法执行完毕后会更新到主内存中，保证可见性，并且上锁，同一时间只能有一个锁对象执行方法，防止指令重排。需注意发生死锁，两边都对接下来需要的资源进行了上锁，导致程序相互等待，无法执行下去

### 二、方法

> wait、notify、notifyAll

都是属于**Object**的方法而不是**Thread**，因为Java设计中锁是对象级别而不是线程级别

3者都需要获取到对象锁（同步块）才能操作，不然报错，考虑安全设计

- wait：使当前线程处于等待，和sleep的区别在于wait放弃当前的对象锁，sleep只是出让CPU，而不放弃对象锁，通常在while内部

- notify：随机唤醒一个处于等待状态的线程，同一个对象锁

- notifyAll：唤醒所有处于等待状态的线程，同一个对象锁，非有序，非统一

### 三、Thread细节

线程的interrupt并不是停止线程，而是中断，在sleep等方法会抛出一个InterruptedException异常，中断会直接抛出此异常

Thread.holdsLock 当前线程是否获取到了对象锁

Thread.yield 当前线程试图让出CPU

join方法：当前线程阻塞指定时长，让出CPU，等待调用者

setDaemon方法：要在start之前调用，将调用者设为当前线程环境的守护线程，当前线程结束时，守护线程也一并结束

### 四、生产者消费者模式

- 利用wait、notifyAll方法来完成多线程之间的通信

- 利用BlockingQueue，方法带有阻塞效果

- [java锁机制](https://github.com/TruthKeeper/Note/blob/master/Java/Java%E9%94%81.md)，newCondition

### 五、并发与并行

并发指系统支持多个操作**同时存在**

并行指系统可以同时处理多个任务

![](https://pic4.zhimg.com/50/v2-674f0d37fca4fac1bd2df28a2b78e633_hd.jpg)
























