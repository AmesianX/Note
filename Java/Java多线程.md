## Java多线程

线程同步问题是由线程的私有内存和堆内存之间不同步导致的，即可见性，进程之间的内存空间不同，线程共享所属进程的堆内存

### 关键字

#### volatile

用来修饰变量

- 修饰的变量对所有线程都是来自主内存最新的，可见性
- 防止编译后的指令重排

不能保证原子性操作，例如i++，在多线程复杂环境下的单例模式下需加该关键字，因为一个类实例化的过程是分步的，先分配内存空间，接着初始化类，最后指向地址

#### synchronized

修饰方法或者代码块，在方法执行完毕后会更新到主内存中，保证可见性，并且上锁，同一时间只能有一个锁对象执行方法，防止指令重排。需注意发生死锁，两边都对接下来需要的资源进行了上锁，导致程序相互等待，无法执行下去

### 方法

> wait、notify、notifyAll

都是属于**Object**的方法而不是**Thread**，因为Java设计中锁是对象级别而不是线程级别

3者都需要获取到对象锁（同步块）才能操作，不然报错，考虑安全设计

- wait：使当前线程处于等待，和sleep的区别在于wait放弃当前的对象锁，sleep只是出让CPU，而不放弃对象锁，通常在while内部

- notify：随机唤醒一个处于等待状态的线程，同一个对象锁

- notifyAll：唤醒所有处于等待状态的线程，同一个对象锁，非有序，非统一

### Thread

线程的interrupt并不是停止线程，而是中断，在sleep等方法会抛出一个InterruptedException异常，中断会直接抛出此异常

Thread.holdsLock 当前线程是否获取到了对象锁

Thread.yield 当前线程试图让出CPU

join方法：当前线程阻塞指定时长，让出CPU，等待调用者

setDaemon方法：要在start之前调用，将调用者设为当前线程环境的守护线程，当前线程结束时，守护线程也一并结束

### 生产者消费者模式

- 利用wait、notifyAll方法来完成多线程之间的通信

- 利用BlockingQueue，方法带有阻塞效果

- Lock机制，newCondition

### Lock

Lock机制弥补了synchronized获取锁时无法中断的缺陷，例如死锁

#### ReentrantLock

可重入锁，排它锁

- lock：死循环获取锁，获取不到则一直阻塞，直到获取到锁

- tryLock：获取一次锁，获取到就返回true，程序继续往下运行，可以设置获取锁的超时时间

- lockInterruptibly：同lock方法，但是响应中断
























